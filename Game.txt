一.      寻路
使用“导航网格（Navigation Mesh）”技术
导航网格的优势是：

‒        对网格进行合并，减少网格数量，减少计算量，提升效率

‒        利用三角形贴合不规则的地形，让拐弯更自然

而带来的缺点是：重构网格相当费时，耗费的时间和地图的阻挡复杂度成正比

使用A星(A-star algorithm)算法
多线程寻路
采用队列来削峰

选择洋流图方案
目的地相同
地图上的每一个网格，都记录了前进的方向，避免大范围的遍历计算


1.	天美工作室群的团队还分享了其自主研发的角色动画系统MotorNerve，以及该系统如何通过结合Motion Matching和Learned Motion Matching的优势，
并利用Motion In Betweening技术，实现高质量、低消耗的位移动作控制与过渡动画生成。
2.	腾讯AI Lab在GDC大会期间推出了自主研发的GiiNEX游戏AI引擎。该游戏AI引擎采用了生成式AI技术，可帮助专业开发者创建拟真、多样的3D城市场景。
此外，它还为玩家提供了设计新关卡等增强UGC创作的机会。
GiiNEX支持包括2D图像、动画、3D场景、剧情等生成，还利用决策人工智能进行游戏开发测试、模拟游戏和场景，以加快游戏创新。


GameInstace是一个正在运行的游戏的高级别的管理对象，在游戏创建时生成，游戏实例关闭时自动销毁，一个游戏可以有多个GameInstace。
	{
		切换关卡不会销毁GameInstance，所以切换关卡需要传递的信息可以通过GameInstance去传递。
		在游戏中，GameInstace可以作为一个全局的类使用，存储在全局位置使用，在蓝图中可以通过获取GameInstace来获取。
	}
GameMode定义了游戏的玩法和规则
	{
		比如你可以在游戏模式里面设置怪物的生成，以及游戏获胜的规则等等。在项目设置中，你可以设置游戏的默认模式。
		你可以使用单一的GameMode来应用到多个不同的关卡，比如多个游戏副本可以适应一套GameMode。
	}
默认的pawn类是默认生成的玩家控制类，一般不会直接在这里设置，会在玩家控制器中去生成。

默认HUD类，HUD是指"抬头显视"或二维屏幕显示。 每个玩家控制器通常都配有其中一种显示

玩家控制类，主要是协助控制玩家的

游戏状态类 GameState包含游戏的状态，其中可以包括联网玩家列表、得分、棋类游戏中棋子的位置，或者在开放世界场景中完成的任务列表。
游戏状态存在于服务器和所有客户端上，可以自由复制以保持所有机器处于最新状态。

玩家状态类 玩家状态 是游戏玩家的状态，例如人类玩家或模拟玩家的机器人。作为游戏的一部分而存在的非玩家AI将不会拥有玩家状态。
在玩家状态中适当的示例数据包括玩家姓名或得分、比赛中MOBA等的等级，或玩家当前是否在CTF游戏中携带旗帜。
所有玩家的玩家状态存在于所有机器上（与玩家控制器不同），并且可以自由复制以保持同步。

旁观者类 其实就是作为第三者，在观察场景内的数据调试时使用，作为一个额外的相机控制器使用，如果在运行时选择模拟，会使用旁观者类进入场景来操控相机



官方简单的RPG里 GameMode实现了
主菜单场景中，游戏模式只是简单的实现了添加ui到视口，和初始化了全局的设置，并保存到本地
而在战斗场景中，事件图表中，播放开场动画，显示剩余游玩事件，开始游戏的处理，游戏结束处理以及重新开始游戏处理
在GameMode里面还有一个图表，用于处理敌人的生成逻辑

玩家控制器是我们和游戏中的角色沟通的媒介，我们需要通过玩家控制器实现对游戏中的角色的控制，所以，很多操作都是需要通过玩家控制器实现。
比如，操作的输入，需要通过玩家控制器输入，如果你在游戏中，打开ui界面，此时，将无法再控制游戏中的角色攻击，移动等操作，都需要通过玩家控制器实现
你需要操作玩家，其实需要设置玩家输入模式游戏
你也可以通过玩家控制器设置不接受任何输入，比如进入自动模式
游戏是否暂停，你也需要通过玩家控制器实现
如果你只允许UI相应用户输入
你也可以设置鼠标光标是否显示
你可以在玩家控制器中获取到控制的角色对象
你甚至可以将角色的移动和朝向直接写在角色控制器里面
在官方案例动作RPG项目中，将玩家查看的HUD界面放到了角色控制器中
还有暂停游戏，打开角色属性栏，设置角色自动战斗
还有过场动画的播放和停止事件（播放停止以后，将创建HUD，战斗模式开始新的游戏，让GameMode生成怪物）
还有打开背包事件的逻辑
以及背包更新，或者修改了装备的更新，都会去更新HUD（On Screen Controls 变量），还调用了角色身上的创建所有持有武器事件，
创建所有持有武器事件放到控制角色身上的原因是删除的时候，可以直接根据角色去删除，不需要通过PlayerController去实现。

PlayerCameraManager 用于为一个特定的玩家管理摄像机。它定义最终查看属性，供渲染器这类的其它系统使用。
PlayerCameraManager的功能类似于一个用来查看世界的 “虚拟眼球”。 
它可以直接计算最终摄像机属性，也能够在其它物体或者影响摄像机的Actor之间混合（从一个CameraActor混合到另外一个）。
可以通过节点获取到当前相机管理器
可以通过相机管理器获取到当前相机的位置和旋转

资产管理器是一个独特的全局对象，可以根据不同的项目进行覆盖和自定义。它提供了一个管理资产的框架，可将内容划分为数据块，对应项目的上下文，
而同时保证虚幻引擎 4 松散打包架构 的优势。unreal会自动处理资产的加载与卸载，在某些情况下需要更精确的控制资产，则需要使用到资产管理器。
资产管理器对象是一个单例，有且唯一，负责主资产的发现与加载。
创建自定义的资源管理器需要书写代码，类继承至UAssetManager
然后在项目设置中，找到一般设置默认类，设置资产管理类
	{
	既然资产管理器可以对主资产进行操作，那么，资产管理器如何实现获取操作
	最简单的就是在项目设置里面，资产管理器中，添加要扫描的主资产类型，并设置相应的目录
	主资产类型我们可以自定义名称的，然后在蓝图中，可以通过类型去获取相应的资源列表
	在官方项目动作RPG中，它在动画实例中加载了三种类型的资产，可以看到，键就是使用主资产类型设置的
	}	
像之前的动作RPG中的，通过主资产类型获取主资产ID列表
异步加载可以有效的防止卡顿，最主要的，如果主资产不需要使用，我们还可以卸载掉，减少内存使用率。
主资产ID中包含两项内容，它们共同组成了主资产ID，分别是主资产类型，和主资产名称
主资产类型就是在资产管理器中设置的类型，名称则是当前的文件名称

要实现自定义主资产的创建，你需要通过c++代码创建，我们可以实现创建一个基于UPrimaryDataAsset创建一个自定义类，而且必须要实现GetPrimaryAssetId方法的覆盖
首先创建一个基于PrimaryDataAsset的c++类

